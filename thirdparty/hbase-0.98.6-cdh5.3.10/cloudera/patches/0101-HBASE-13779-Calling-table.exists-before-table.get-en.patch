From 273bde412b435ae33b4346fc7dac2ec99123bbe5 Mon Sep 17 00:00:00 2001
From: Matteo Bertozzi <matteo.bertozzi@cloudera.com>
Date: Fri, 29 May 2015 18:26:18 +0100
Subject: [PATCH 101/157] HBASE-13779 Calling table.exists() before
 table.get() end up with an empty Result + addendum

Reason: Bug
Author: Matteo Bertozzi
Ref: CDH-28244
---
 .../java/org/apache/hadoop/hbase/client/Get.java   |   20 ++++--
 .../org/apache/hadoop/hbase/client/HTable.java     |   28 ++++++--
 .../org/apache/hadoop/hbase/client/TestGet.java    |   39 +++++++++++
 .../hadoop/hbase/client/TestFromClientSide3.java   |   68 ++++++++++++++++++--
 4 files changed, 139 insertions(+), 16 deletions(-)

diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/Get.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/Get.java
index c18512d..d296449 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/Get.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/Get.java
@@ -96,6 +96,7 @@ public class Get extends Query
    * @param get
    */
   public Get(Get get) {
+    this(get.getRow());
     this.filter = get.getFilter();
     this.cacheBlocks = get.getCacheBlocks();
     this.maxVersions = get.getMaxVersions();
@@ -104,7 +105,18 @@ public class Get extends Query
     this.tr = get.getTimeRange();
     this.checkExistenceOnly = get.isCheckExistenceOnly();
     this.closestRowBefore = get.isClosestRowBefore();
-    this.familyMap = get.getFamilyMap();
+    Map<byte[], NavigableSet<byte[]>> fams = get.getFamilyMap();
+    for (Map.Entry<byte[],NavigableSet<byte[]>> entry : fams.entrySet()) {
+      byte [] fam = entry.getKey();
+      NavigableSet<byte[]> cols = entry.getValue();
+      if (cols != null && cols.size() > 0) {
+        for (byte[] col : cols) {
+          addColumn(fam, col);
+        }
+      } else {
+        addFamily(fam);
+      }
+    }
     for (Map.Entry<String, byte[]> attr : get.getAttributesMap().entrySet()) {
       setAttribute(attr.getKey(), attr.getValue());
     }
@@ -367,7 +379,7 @@ public class Get extends Query
   public Map<String, Object> toMap(int maxCols) {
     // we start with the fingerprint map and build on top of it.
     Map<String, Object> map = getFingerprint();
-    // replace the fingerprint's simple list of families with a 
+    // replace the fingerprint's simple list of families with a
     // map from column families to lists of qualifiers and kv details
     Map<String, List<String>> columns = new HashMap<String, List<String>>();
     map.put("families", columns);
@@ -400,8 +412,8 @@ public class Get extends Query
           }
           familyList.add(Bytes.toStringBinary(column));
         }
-      }   
-    }   
+      }
+    }
     map.put("totalColumns", colCount);
     if (this.filter != null) {
       map.put("filter", this.filter.toString());
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/HTable.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/HTable.java
index dd18942..dbe465e 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/HTable.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/HTable.java
@@ -72,6 +72,7 @@ import org.apache.hadoop.hbase.protobuf.generated.ClientProtos.RegionAction;
 import org.apache.hadoop.hbase.protobuf.generated.HBaseProtos.CompareType;
 import org.apache.hadoop.hbase.util.Bytes;
 import org.apache.hadoop.hbase.util.Pair;
+import org.apache.hadoop.hbase.util.ReflectionUtils;
 import org.apache.hadoop.hbase.util.Threads;
 
 import com.google.protobuf.Descriptors;
@@ -220,7 +221,7 @@ public class HTable implements HTableInterface {
     this.pool = getDefaultExecutor(this.configuration);
     this.finishSetup();
   }
-   
+
   public static ThreadPoolExecutor getDefaultExecutor(Configuration conf) {
     int maxThreads = conf.getInt("hbase.htable.threads.max", Integer.MAX_VALUE);
     if (maxThreads == 0) {
@@ -766,16 +767,27 @@ public class HTable implements HTableInterface {
    */
   @Override
   public Result get(final Get get) throws IOException {
+    return get(get, get.isCheckExistenceOnly());
+  }
+
+  private Result get(Get get, final boolean checkExistenceOnly) throws IOException {
+    // if we are changing settings to the get, clone it.
+    if (get.isCheckExistenceOnly() != checkExistenceOnly) {
+      get = ReflectionUtils.newInstance(get.getClass(), get);
+      get.setCheckExistenceOnly(checkExistenceOnly);
+    }
+
     // have to instanatiate this and set the priority here since in protobuf util we don't pass in
     // the tablename... an unfortunate side-effect of public interfaces :-/ In 0.99+ we put all the
     // logic back into HTable
     final PayloadCarryingRpcController controller = rpcControllerFactory.newController();
     controller.setPriority(tableName);
+    final Get getReq = get;
     RegionServerCallable<Result> callable =
         new RegionServerCallable<Result>(this.connection, getName(), get.getRow()) {
           public Result call() throws IOException {
-            return ProtobufUtil.get(getStub(), getLocation().getRegionInfo().getRegionName(), get,
-              controller);
+            return ProtobufUtil.get(getStub(), getLocation().getRegionInfo().getRegionName(),
+              getReq, controller);
           }
         };
     return rpcCallerFactory.<Result> newCaller().callWithRetries(callable, this.operationTimeout);
@@ -1235,8 +1247,7 @@ public class HTable implements HTableInterface {
    */
   @Override
   public boolean exists(final Get get) throws IOException {
-    get.setCheckExistenceOnly(true);
-    Result r = get(get);
+    Result r = get(get, true);
     assert r.getExists() != null;
     return r.getExists();
   }
@@ -1249,13 +1260,16 @@ public class HTable implements HTableInterface {
     if (gets.isEmpty()) return new Boolean[]{};
     if (gets.size() == 1) return new Boolean[]{exists(gets.get(0))};
 
+    ArrayList<Get> exists = new ArrayList<Get>(gets.size());
     for (Get g: gets){
-      g.setCheckExistenceOnly(true);
+      Get ge = new Get(g);
+      ge.setCheckExistenceOnly(true);
+      exists.add(ge);
     }
 
     Object[] r1;
     try {
-      r1 = batch(gets);
+      r1 = batch(exists);
     } catch (InterruptedException e) {
       throw (InterruptedIOException)new InterruptedIOException().initCause(e);
     }
diff --git a/hbase-client/src/test/java/org/apache/hadoop/hbase/client/TestGet.java b/hbase-client/src/test/java/org/apache/hadoop/hbase/client/TestGet.java
index f11633d..29be58e 100644
--- a/hbase-client/src/test/java/org/apache/hadoop/hbase/client/TestGet.java
+++ b/hbase-client/src/test/java/org/apache/hadoop/hbase/client/TestGet.java
@@ -41,6 +41,8 @@ import org.apache.hadoop.hbase.filter.FilterList;
 import org.apache.hadoop.hbase.filter.KeyOnlyFilter;
 import org.apache.hadoop.hbase.protobuf.ProtobufUtil;
 import org.apache.hadoop.hbase.protobuf.generated.ClientProtos;
+import org.apache.hadoop.hbase.security.access.Permission;
+import org.apache.hadoop.hbase.security.visibility.Authorizations;
 import org.apache.hadoop.hbase.util.Base64;
 import org.apache.hadoop.hbase.util.Bytes;
 import org.junit.Assert;
@@ -156,6 +158,43 @@ public class TestGet {
   }
 
   @Test
+  public void TestGetRowFromGetCopyConstructor() throws Exception {
+    Get get = new Get(ROW);
+    get.setFilter(null);
+    get.setAuthorizations(new Authorizations("foo"));
+    get.setACL("u", new Permission(Permission.Action.READ));
+    get.setCheckExistenceOnly(true);
+    get.setClosestRowBefore(true);
+    get.setTimeRange(3, 4);
+    get.setMaxVersions(11);
+    get.setMaxResultsPerColumnFamily(10);
+    get.setRowOffsetPerColumnFamily(11);
+    get.setCacheBlocks(true);
+
+    Get copyGet = new Get(get);
+    assertEquals(0, Bytes.compareTo(get.getRow(), copyGet.getRow()));
+
+    // from OperationWithAttributes
+    assertEquals(get.getId(), copyGet.getId());
+
+    // from Query class
+    assertEquals(get.getFilter(), copyGet.getFilter());
+    assertTrue(get.getAuthorizations().toString().equals(copyGet.getAuthorizations().toString()));
+    assertTrue(Bytes.equals(get.getACL(), copyGet.getACL()));
+
+    // from Get class
+    assertEquals(get.isCheckExistenceOnly(), copyGet.isCheckExistenceOnly());
+    assertEquals(get.isClosestRowBefore(), copyGet.isClosestRowBefore());
+    assertTrue(get.getTimeRange().equals(copyGet.getTimeRange()));
+    assertEquals(get.isClosestRowBefore(), copyGet.isClosestRowBefore());
+    assertEquals(get.getMaxVersions(), copyGet.getMaxVersions());
+    assertEquals(get.getMaxResultsPerColumnFamily(), copyGet.getMaxResultsPerColumnFamily());
+    assertEquals(get.getRowOffsetPerColumnFamily(), copyGet.getRowOffsetPerColumnFamily());
+    assertEquals(get.getCacheBlocks(), copyGet.getCacheBlocks());
+    assertEquals(get.getId(), copyGet.getId());
+  }
+
+  @Test
   public void testDynamicFilter() throws Exception {
     Configuration conf = HBaseConfiguration.create();
     String localPath = conf.get("hbase.local.dir")
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestFromClientSide3.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestFromClientSide3.java
index e19f44c..61a70fd 100644
--- a/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestFromClientSide3.java
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestFromClientSide3.java
@@ -95,7 +95,10 @@ public class TestFromClientSide3 {
    */
   @After
   public void tearDown() throws Exception {
-    // Nothing to do.
+    for (HTableDescriptor htd: TEST_UTIL.getHBaseAdmin().listTables()) {
+      LOG.info("Tear down, remove table=" + htd.getTableName());
+      TEST_UTIL.deleteTable(htd.getTableName());
+    }
   }
 
   private void randomCFPuts(HTable table, byte[] row, byte[] family, int nPuts)
@@ -277,20 +280,20 @@ public class TestFromClientSide3 {
       // create an empty Put
       Put put1 = new Put(ROW);
       actions.add(put1);
-      
+
       Put put2 = new Put(ANOTHERROW);
       put2.add(FAMILY, QUALIFIER, VALUE);
       actions.add(put2);
-      
+
       table.batch(actions, results);
       fail("Empty Put should have failed the batch call");
     } catch (IllegalArgumentException iae) {
-      
+
     } finally {
       table.close();
     }
   }
-  
+
   @Test
   public void testHTableExistsMethodSingleRegionSingleGet() throws Exception {
 
@@ -431,4 +434,59 @@ public class TestFromClientSide3 {
     assertTrue(Arrays.equals(res.getValue(FAMILY, COL_QUAL), VAL_BYTES));
     table.close();
   }
+
+  @Test
+  public void testHTableExistsBeforeGet() throws Exception {
+    HTable table = TEST_UTIL.createTable(
+      Bytes.toBytes("testHTableExistsBeforeGet"), new byte[][] { FAMILY });
+    try {
+      Put put = new Put(ROW);
+      put.add(FAMILY, QUALIFIER, VALUE);
+      table.put(put);
+
+      Get get = new Get(ROW);
+
+      boolean exist = table.exists(get);
+      assertEquals(true, exist);
+
+      Result result = table.get(get);
+      assertEquals(false, result.isEmpty());
+      assertTrue(Bytes.equals(VALUE, result.getValue(FAMILY, QUALIFIER)));
+    } finally {
+      table.close();
+    }
+  }
+
+  @Test
+  public void testHTableExistsAllBeforeGet() throws Exception {
+    final byte[] ROW2 = Bytes.add(ROW, Bytes.toBytes("2"));
+    HTable table = TEST_UTIL.createTable(
+      Bytes.toBytes("testHTableExistsAllBeforeGet"), new byte[][] { FAMILY });
+    try {
+      Put put = new Put(ROW);
+      put.add(FAMILY, QUALIFIER, VALUE);
+      table.put(put);
+      put = new Put(ROW2);
+      put.add(FAMILY, QUALIFIER, VALUE);
+      table.put(put);
+
+      Get get = new Get(ROW);
+      Get get2 = new Get(ROW2);
+      ArrayList<Get> getList = new ArrayList(2);
+      getList.add(get);
+      getList.add(get2);
+
+      Boolean[] exists = table.exists(getList);
+      assertEquals(true, exists[0]);
+      assertEquals(true, exists[1]);
+
+      Result[] result = table.get(getList);
+      assertEquals(false, result[0].isEmpty());
+      assertTrue(Bytes.equals(VALUE, result[0].getValue(FAMILY, QUALIFIER)));
+      assertEquals(false, result[1].isEmpty());
+      assertTrue(Bytes.equals(VALUE, result[1].getValue(FAMILY, QUALIFIER)));
+    } finally {
+      table.close();
+    }
+  }
 }
-- 
1.7.9.5

