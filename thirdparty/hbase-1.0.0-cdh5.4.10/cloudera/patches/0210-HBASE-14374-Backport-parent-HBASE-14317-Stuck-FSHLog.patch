From 68c136e9ffd45d10a4f21db8386a78570e795f28 Mon Sep 17 00:00:00 2001
From: stack <stack@duboce.net>
Date: Mon, 23 Nov 2015 15:53:56 -0800
Subject: [PATCH 210/226]     HBASE-14374 Backport parent 'HBASE-14317 Stuck
 FSHLog' issue to 1.1     Also includes HBASE-14807
 TestWALLockup is flakey     Addendum: Forgot to add
 files.

      Reason: Bug
      Author: Stack
      Ref: CDH-33545
      Ref: CDH-34708 CU hits HBASE-14317

    Change-Id: Ic488f9b1302c9145816fa1ab7eeb709cf51117e6
---
 .../regionserver/wal/DamagedWALException.java      |   45 +++
 .../regionserver/TestFailedAppendAndSync.java      |  273 ++++++++++++++++++
 .../hadoop/hbase/regionserver/TestWALLockup.java   |  292 ++++++++++++++++++++
 3 files changed, 610 insertions(+)
 create mode 100644 hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/DamagedWALException.java
 create mode 100644 hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestFailedAppendAndSync.java
 create mode 100644 hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestWALLockup.java

diff --git a/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/DamagedWALException.java b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/DamagedWALException.java
new file mode 100644
index 0000000..6c57f56
--- /dev/null
+++ b/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/DamagedWALException.java
@@ -0,0 +1,45 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.regionserver.wal;
+
+import org.apache.hadoop.hbase.HBaseIOException;
+import org.apache.hadoop.hbase.classification.InterfaceAudience;
+
+/**
+ * Thrown when a failed append or sync on a WAL.
+ * Thrown when WAL can no longer be used. Roll the WAL.
+ */
+@SuppressWarnings("serial")
+@InterfaceAudience.Private
+public class DamagedWALException extends HBaseIOException {
+  public DamagedWALException() {
+    super();
+  }
+
+  public DamagedWALException(String message) {
+    super(message);
+  }
+
+  public DamagedWALException(String message, Throwable cause) {
+    super(message, cause);
+  }
+
+  public DamagedWALException(Throwable cause) {
+    super(cause);
+  }
+}
\ No newline at end of file
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestFailedAppendAndSync.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestFailedAppendAndSync.java
new file mode 100644
index 0000000..945361f
--- /dev/null
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestFailedAppendAndSync.java
@@ -0,0 +1,273 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.regionserver;
+
+
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.io.IOException;
+import java.util.concurrent.atomic.AtomicLong;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.fs.FileSystem;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.hbase.DroppedSnapshotException;
+import org.apache.hadoop.hbase.HBaseTestingUtility;
+import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.Server;
+import org.apache.hadoop.hbase.TableName;
+import org.apache.hadoop.hbase.client.Durability;
+import org.apache.hadoop.hbase.client.Put;
+import org.apache.hadoop.hbase.regionserver.wal.FSHLog;
+import org.apache.hadoop.hbase.regionserver.wal.FailedLogCloseException;
+import org.apache.hadoop.hbase.testclassification.MediumTests;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hadoop.hbase.util.EnvironmentEdgeManagerTestHelper;
+import org.apache.hadoop.hbase.util.Threads;
+import org.apache.hadoop.hbase.wal.WAL;
+import org.apache.hadoop.hbase.wal.WALProvider.Writer;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+import org.junit.rules.TestName;
+import org.mockito.Mockito;
+import org.mockito.exceptions.verification.WantedButNotInvoked;
+
+/**
+ * Testing sync/append failures.
+ * Copied from TestHRegion.
+ */
+@Category({MediumTests.class})
+public class TestFailedAppendAndSync {
+  private static final Log LOG = LogFactory.getLog(TestFailedAppendAndSync.class);
+  @Rule public TestName name = new TestName();
+
+  private static final String COLUMN_FAMILY = "MyCF";
+  private static final byte [] COLUMN_FAMILY_BYTES = Bytes.toBytes(COLUMN_FAMILY);
+
+  HRegion region = null;
+  // Do not run unit tests in parallel (? Why not?  It don't work?  Why not?  St.Ack)
+  private static HBaseTestingUtility TEST_UTIL;
+  public static Configuration CONF ;
+  private String dir;
+
+  // Test names
+  protected TableName tableName;
+
+  @Before
+  public void setup() throws IOException {
+    TEST_UTIL = HBaseTestingUtility.createLocalHTU();
+    CONF = TEST_UTIL.getConfiguration();
+    // Disable block cache.
+    CONF.setFloat(HConstants.HFILE_BLOCK_CACHE_SIZE_KEY, 0f);
+    dir = TEST_UTIL.getDataTestDir("TestHRegion").toString();
+    tableName = TableName.valueOf(name.getMethodName());
+  }
+
+  @After
+  public void tearDown() throws Exception {
+    EnvironmentEdgeManagerTestHelper.reset();
+    LOG.info("Cleaning test directory: " + TEST_UTIL.getDataTestDir());
+    TEST_UTIL.cleanupTestDir();
+  }
+
+  String getName() {
+    return name.getMethodName();
+  }
+
+  /**
+   * Reproduce locking up that happens when we get an exceptions appending and syncing.
+   * See HBASE-14317.
+   * First I need to set up some mocks for Server and RegionServerServices. I also need to
+   * set up a dodgy WAL that will throw an exception when we go to append to it.
+   */
+  @Test (timeout=300000)
+  public void testLockupAroundBadAssignSync() throws IOException {
+    final AtomicLong rolls = new AtomicLong(0);
+    // Dodgy WAL. Will throw exceptions when flags set.
+    class DodgyFSLog extends FSHLog {
+      volatile boolean throwSyncException = false;
+      volatile boolean throwAppendException = false;
+
+      public DodgyFSLog(FileSystem fs, Path root, String logDir, Configuration conf)
+      throws IOException {
+        super(fs, root, logDir, conf);
+      }
+
+      @Override
+      public byte[][] rollWriter(boolean force) throws FailedLogCloseException, IOException {
+        byte [][] regions = super.rollWriter(force);
+        rolls.getAndIncrement();
+        return regions;
+      }
+
+      @Override
+      protected Writer createWriterInstance(Path path) throws IOException {
+        final Writer w = super.createWriterInstance(path);
+          return new Writer() {
+            @Override
+            public void close() throws IOException {
+              w.close();
+            }
+
+            @Override
+            public void sync() throws IOException {
+              if (throwSyncException) {
+                throw new IOException("FAKE! Failed to replace a bad datanode...");
+              }
+              w.sync();
+            }
+
+            @Override
+            public void append(Entry entry) throws IOException {
+              if (throwAppendException) {
+                throw new IOException("FAKE! Failed to replace a bad datanode...");
+              }
+              w.append(entry);
+            }
+
+            @Override
+            public long getLength() throws IOException {
+              return w.getLength();
+              }
+            };
+          }
+      }
+
+    // Make up mocked server and services.
+    Server server = mock(Server.class);
+    when(server.getConfiguration()).thenReturn(CONF);
+    when(server.isStopped()).thenReturn(false);
+    when(server.isAborted()).thenReturn(false);
+    RegionServerServices services = mock(RegionServerServices.class);
+    // OK. Now I have my mocked up Server and RegionServerServices and my dodgy WAL, go ahead with
+    // the test.
+    FileSystem fs = FileSystem.get(CONF);
+    Path rootDir = new Path(dir + getName());
+    DodgyFSLog dodgyWAL = new DodgyFSLog(fs, rootDir, getName(), CONF);
+    LogRoller logRoller = new LogRoller(server, services);
+    logRoller.addWAL(dodgyWAL);
+    logRoller.start();
+
+    boolean threwOnSync = false;
+    boolean threwOnAppend = false;
+    boolean threwOnBoth = false;
+
+    HRegion region = initHRegion(tableName, null, null, dodgyWAL);
+    try {
+      // Get some random bytes.
+      byte[] value = Bytes.toBytes(getName());
+      try {
+        // First get something into memstore
+        Put put = new Put(value);
+        put.addColumn(COLUMN_FAMILY_BYTES, Bytes.toBytes("1"), value);
+        region.put(put);
+      } catch (IOException ioe) {
+        fail();
+      }
+      long rollsCount = rolls.get();
+      try {
+        dodgyWAL.throwAppendException = true;
+        dodgyWAL.throwSyncException = false;
+        Put put = new Put(value);
+        put.addColumn(COLUMN_FAMILY_BYTES, Bytes.toBytes("3"), value);
+        region.put(put);
+      } catch (IOException ioe) {
+        threwOnAppend = true;
+      }
+      while (rollsCount == rolls.get()) Threads.sleep(100);
+      rollsCount = rolls.get();
+
+      // When we get to here.. we should be ok. A new WAL has been put in place. There were no
+      // appends to sync. We should be able to continue.
+
+      try {
+        dodgyWAL.throwAppendException = true;
+        dodgyWAL.throwSyncException = true;
+        Put put = new Put(value);
+        put.addColumn(COLUMN_FAMILY_BYTES, Bytes.toBytes("4"), value);
+        region.put(put);
+      } catch (IOException ioe) {
+        threwOnBoth = true;
+      }
+      while (rollsCount == rolls.get()) Threads.sleep(100);
+
+      // Again, all should be good. New WAL and no outstanding unsync'd edits so we should be able
+      // to just continue.
+
+      // So, should be no abort at this stage. Verify.
+      Mockito.verify(server, Mockito.atLeast(0)).
+        abort(Mockito.anyString(), (Throwable)Mockito.anyObject());
+      try {
+        dodgyWAL.throwAppendException = false;
+        dodgyWAL.throwSyncException = true;
+        Put put = new Put(value);
+        put.addColumn(COLUMN_FAMILY_BYTES, Bytes.toBytes("2"), value);
+        region.put(put);
+      } catch (IOException ioe) {
+        threwOnSync = true;
+      }
+      // An append in the WAL but the sync failed is a server abort condition. That is our
+      // current semantic. Verify. It takes a while for abort to be called. Just hang here till it
+      // happens. If it don't we'll timeout the whole test. That is fine.
+      while (true) {
+        try {
+          Mockito.verify(server, Mockito.atLeast(1)).
+            abort(Mockito.anyString(), (Throwable)Mockito.anyObject());
+          break;
+        } catch (WantedButNotInvoked t) {
+          Threads.sleep(1);
+        }
+      }
+    } finally {
+      // To stop logRoller, its server has to say it is stopped.
+      Mockito.when(server.isStopped()).thenReturn(true);
+      if (logRoller != null) logRoller.interrupt();
+      if (region != null) {
+        try {
+          region.close(true);
+        } catch (DroppedSnapshotException e) {
+          LOG.info("On way out; expected!", e);
+        }
+      }
+      if (dodgyWAL != null) dodgyWAL.close();
+      assertTrue("The regionserver should have thrown an exception", threwOnBoth);
+      assertTrue("The regionserver should have thrown an exception", threwOnAppend);
+      assertTrue("The regionserver should have thrown an exception", threwOnSync);
+    }
+  }
+
+  /**
+   * @return A region on which you must call
+   *         {@link HBaseTestingUtility#closeRegionAndWAL(HRegion)} when done.
+   */
+  public HRegion initHRegion(TableName tableName, byte[] startKey, byte[] stopKey, WAL wal)
+  throws IOException {
+    return TEST_UTIL.createLocalHRegion(tableName.getName(), startKey, stopKey,
+      getName(), CONF, false, Durability.SYNC_WAL,
+      wal, COLUMN_FAMILY_BYTES);
+  }
+}
\ No newline at end of file
diff --git a/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestWALLockup.java b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestWALLockup.java
new file mode 100644
index 0000000..f0c2b30
--- /dev/null
+++ b/hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestWALLockup.java
@@ -0,0 +1,292 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.regionserver;
+
+
+import static org.junit.Assert.assertTrue;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.fs.FileSystem;
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.hbase.Cell;
+import org.apache.hadoop.hbase.CellScanner;
+import org.apache.hadoop.hbase.HBaseTestingUtility;
+import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.HTableDescriptor;
+import org.apache.hadoop.hbase.Server;
+import org.apache.hadoop.hbase.TableName;
+import org.apache.hadoop.hbase.client.Durability;
+import org.apache.hadoop.hbase.client.Put;
+import org.apache.hadoop.hbase.regionserver.wal.FSHLog;
+import org.apache.hadoop.hbase.regionserver.wal.WALEdit;
+import org.apache.hadoop.hbase.testclassification.MediumTests;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.hadoop.hbase.util.EnvironmentEdgeManagerTestHelper;
+import org.apache.hadoop.hbase.util.Threads;
+import org.apache.hadoop.hbase.wal.WAL;
+import org.apache.hadoop.hbase.wal.WALKey;
+import org.apache.hadoop.hbase.wal.WALProvider.Writer;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+import org.junit.rules.TestName;
+import org.mockito.Mockito;
+
+/**
+ * Testing for lock up of WAL subsystem.
+ * Copied from TestHRegion.
+ */
+@Category({MediumTests.class})
+public class TestWALLockup {
+  private static final Log LOG = LogFactory.getLog(TestWALLockup.class);
+  @Rule public TestName name = new TestName();
+
+  private static final String COLUMN_FAMILY = "MyCF";
+  private static final byte [] COLUMN_FAMILY_BYTES = Bytes.toBytes(COLUMN_FAMILY);
+
+  HRegion region = null;
+  // Do not run unit tests in parallel (? Why not?  It don't work?  Why not?  St.Ack)
+  private static HBaseTestingUtility TEST_UTIL;
+  private static Configuration CONF ;
+  private String dir;
+
+  // Test names
+  protected TableName tableName;
+
+  @Before
+  public void setup() throws IOException {
+    TEST_UTIL = HBaseTestingUtility.createLocalHTU();
+    CONF = TEST_UTIL.getConfiguration();
+    // Disable block cache.
+    CONF.setFloat(HConstants.HFILE_BLOCK_CACHE_SIZE_KEY, 0f);
+    dir = TEST_UTIL.getDataTestDir("TestHRegion").toString();
+    tableName = TableName.valueOf(name.getMethodName());
+  }
+
+  @After
+  public void tearDown() throws Exception {
+    EnvironmentEdgeManagerTestHelper.reset();
+    LOG.info("Cleaning test directory: " + TEST_UTIL.getDataTestDir());
+    TEST_UTIL.cleanupTestDir();
+  }
+
+  String getName() {
+    return name.getMethodName();
+  }
+
+  /**
+   * Reproduce locking up that happens when we get an inopportune sync during setup for
+   * zigzaglatch wait. See HBASE-14317. If below is broken, we will see this test timeout because
+   * it is locked up.
+   * <p>First I need to set up some mocks for Server and RegionServerServices. I also need to
+   * set up a dodgy WAL that will throw an exception when we go to append to it.
+   */
+  @Test // (timeout=15000)
+  public void testLockupWhenSyncInMiddleOfZigZagSetup() throws IOException {
+    // A WAL that we can have throw exceptions when a flag is set.
+    class DodgyFSLog extends FSHLog {
+      // Set this when want the WAL to start throwing exceptions.
+      volatile boolean throwException = false;
+
+      // Latch to hold up processing until after another operation has had time to run.
+      CountDownLatch latch = new CountDownLatch(1);
+
+      public DodgyFSLog(FileSystem fs, Path root, String logDir, Configuration conf)
+      throws IOException {
+        super(fs, root, logDir, conf);
+      }
+
+      @Override
+      protected void afterCreatingZigZagLatch() {
+        // If throwException set, then append will throw an exception causing the WAL to be
+        // rolled. We'll come in here. Hold up processing until a sync can get in before
+        // the zigzag has time to complete its setup and get its own sync in. This is what causes
+        // the lock up we've seen in production.
+        if (throwException) {
+          try {
+            LOG.info("LATCHED");
+            // So, timing can have it that the test can run and the bad flush below happens
+            // before we get here. In this case, we'll be stuck waiting on this latch but there
+            // is nothing in the WAL pipeline to get us to the below beforeWaitOnSafePoint...
+            // because all WALs have rolled. In this case, just give up on test.
+            if (!this.latch.await(5, TimeUnit.SECONDS)) {
+              LOG.warn("GIVE UP! Failed waiting on latch...Test is ABORTED!");
+            }
+          } catch (InterruptedException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+          }
+        }
+      }
+
+      @Override
+      protected void beforeWaitOnSafePoint() {
+        if (throwException) {
+          LOG.info("COUNTDOWN");
+          // Don't countdown latch until someone waiting on it otherwise, the above
+          // afterCreatingZigZagLatch will get to the latch and no one will ever free it and we'll
+          // be stuck; test won't go down
+          while (this.latch.getCount() <= 0) Threads.sleep(1);
+          this.latch.countDown();
+        }
+      }
+
+      @Override
+      protected Writer createWriterInstance(Path path) throws IOException {
+        final Writer w = super.createWriterInstance(path);
+        return new Writer() {
+          @Override
+          public void close() throws IOException {
+            w.close();
+          }
+
+          @Override
+          public void sync() throws IOException {
+            if (throwException) {
+              throw new IOException("FAKE! Failed to replace a bad datanode...SYNC");
+            }
+            w.sync();
+          }
+
+          @Override
+          public void append(Entry entry) throws IOException {
+            if (throwException) {
+              throw new IOException("FAKE! Failed to replace a bad datanode...APPEND");
+            }
+            w.append(entry);
+          }
+
+          @Override
+          public long getLength() throws IOException {
+            return w.getLength();
+          }
+        };
+      }
+    }
+
+    // Mocked up server and regionserver services. Needed below.
+    Server server = Mockito.mock(Server.class);
+    Mockito.when(server.getConfiguration()).thenReturn(CONF);
+    Mockito.when(server.isStopped()).thenReturn(false);
+    Mockito.when(server.isAborted()).thenReturn(false);
+    RegionServerServices services = Mockito.mock(RegionServerServices.class);
+
+    // OK. Now I have my mocked up Server & RegionServerServices and dodgy WAL, go ahead with test.
+    FileSystem fs = FileSystem.get(CONF);
+    Path rootDir = new Path(dir + getName());
+    DodgyFSLog dodgyWAL = new DodgyFSLog(fs, rootDir, getName(), CONF);
+    Path originalWAL = dodgyWAL.getCurrentFileName();
+    // I need a log roller running.
+    LogRoller logRoller = new LogRoller(server, services);
+    logRoller.addWAL(dodgyWAL);
+    // There is no 'stop' once a logRoller is running.. it just dies.
+    logRoller.start();
+    // Now get a region and start adding in edits.
+    HTableDescriptor htd = new HTableDescriptor(TableName.META_TABLE_NAME);
+    final HRegion region = initHRegion(tableName, null, null, dodgyWAL);
+    byte [] bytes = Bytes.toBytes(getName());
+    try {
+      // First get something into memstore. Make a Put and then pull the Cell out of it. Will
+      // manage append and sync carefully in below to manufacture hang. We keep adding same
+      // edit. WAL subsystem doesn't care.
+      Put put = new Put(bytes);
+      put.addColumn(COLUMN_FAMILY_BYTES, Bytes.toBytes("1"), bytes);
+      WALKey key = new WALKey(region.getRegionInfo().getEncodedNameAsBytes(), htd.getTableName());
+      WALEdit edit = new WALEdit();
+      CellScanner CellScanner = put.cellScanner();
+      assertTrue(CellScanner.advance());
+      edit.add(CellScanner.current());
+      List<Cell> cells = new ArrayList<Cell>();
+      for (CellScanner cs = put.cellScanner(); cs.advance();) {
+        edit.add(cs.current());
+        cells.add(cs.current());
+      }
+      // Put something in memstore and out in the WAL. Do a big number of appends so we push
+      // out other side of the ringbuffer. If small numbers, stuff doesn't make it to WAL
+      for (int i = 0; i < 1000; i++) {
+        region.put(put);
+      }
+      // Set it so we start throwing exceptions.
+      LOG.info("SET throwing of exception on append");
+      dodgyWAL.throwException = true;
+      // This append provokes a WAL roll.
+      dodgyWAL.append(htd, region.getRegionInfo(), key, edit, region.getSequenceId(), true, cells);
+      boolean exception = false;
+      try {
+        dodgyWAL.sync();
+      } catch (Exception e) {
+        exception = true;
+      }
+      assertTrue("Did not get sync exception", exception);
+
+      // Get a memstore flush going too so we have same hung profile as up in the issue over
+      // in HBASE-14317. Flush hangs trying to get sequenceid because the ringbuffer is held up
+      // by the zigzaglatch waiting on syncs to come home.
+      Thread t = new Thread ("Flusher") {
+        public void run() {
+          try {
+            if (region.getMemstoreSize().get() <= 0) {
+              throw new IOException("memstore size=" + region.getMemstoreSize());
+            }
+            region.flushcache(false);
+          } catch (IOException e) {
+            LOG.info("In flush", e);
+          }
+          LOG.info("Exiting");
+        };
+      };
+      t.setDaemon(true);
+      t.start();
+      // Wait until latch is thrown.
+      while (dodgyWAL.latch.getCount() > 0) Threads.sleep(1);
+      // Now assert I got a new WAL file put in place even though loads of errors above.
+      assertTrue(originalWAL != dodgyWAL.getCurrentFileName());
+      // Can I append to it?
+      dodgyWAL.throwException = false;
+      region.put(put);
+    } finally {
+      // To stop logRoller, its server has to say it is stopped.
+      Mockito.when(server.isStopped()).thenReturn(true);
+      if (logRoller != null) logRoller.interrupt();
+      if (region != null) region.close();
+      if (dodgyWAL != null) dodgyWAL.close();
+    }
+  }
+
+  /**
+   * @return A region on which you must call
+   *         {@link HBaseTestingUtility#closeRegionAndWAL(HRegion)} when done.
+   */
+  public HRegion initHRegion(TableName tableName, byte[] startKey, byte[] stopKey, WAL wal)
+  throws IOException {
+    return TEST_UTIL.createLocalHRegion(tableName.getName(), startKey, stopKey,
+      getName(), CONF, false, Durability.SYNC_WAL,
+      wal, COLUMN_FAMILY_BYTES);
+  }
+}
-- 
1.7.9.5

